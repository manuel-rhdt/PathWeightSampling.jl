<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hybrid Continuous-Discrete System · PathWeightSampling.jl</title><meta name="title" content="Hybrid Continuous-Discrete System · PathWeightSampling.jl"/><meta property="og:title" content="Hybrid Continuous-Discrete System · PathWeightSampling.jl"/><meta property="twitter:title" content="Hybrid Continuous-Discrete System · PathWeightSampling.jl"/><meta name="description" content="Documentation for PathWeightSampling.jl."/><meta property="og:description" content="Documentation for PathWeightSampling.jl."/><meta property="twitter:description" content="Documentation for PathWeightSampling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PathWeightSampling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../three_species_tutorial/">Three-Species Cascade</a></li><li class="is-active"><a class="tocitem" href>Hybrid Continuous-Discrete System</a><ul class="internal"><li><a class="tocitem" href="#The-Hybrid-Model"><span>The Hybrid Model</span></a></li><li><a class="tocitem" href="#Setting-Up-the-System"><span>Setting Up the System</span></a></li><li><a class="tocitem" href="#Generating-and-Visualizing-Trajectories"><span>Generating and Visualizing Trajectories</span></a></li><li><a class="tocitem" href="#Equilibrium-Statistics"><span>Equilibrium Statistics</span></a></li><li><a class="tocitem" href="#Computing-Mutual-Information"><span>Computing Mutual Information</span></a></li><li><a class="tocitem" href="#Key-Concepts-for-Hybrid-Systems"><span>Key Concepts for Hybrid Systems</span></a></li><li><a class="tocitem" href="#Comparison-with-Pure-Discrete-Systems"><span>Comparison with Pure Discrete Systems</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../marginalization/">Marginalization Strategies</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../systems/">System Types</a></li><li><a class="tocitem" href="../write_output/">Output &amp; Saving</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Hybrid Continuous-Discrete System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hybrid Continuous-Discrete System</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/manuel-rhdt/PathWeightSampling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/manuel-rhdt/PathWeightSampling.jl/blob/master/docs/src/hybrid_system_tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hybrid-Continuous-Discrete-System-Tutorial"><a class="docs-heading-anchor" href="#Hybrid-Continuous-Discrete-System-Tutorial">Hybrid Continuous-Discrete System Tutorial</a><a id="Hybrid-Continuous-Discrete-System-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-Continuous-Discrete-System-Tutorial" title="Permalink"></a></h1><p>This tutorial demonstrates how to analyze information flow in a hybrid stochastic system that combines continuous dynamics (described by stochastic differential equations) with discrete jump events. This is particularly relevant for biological systems where some species evolve continuously while others change through discrete reactions.</p><h2 id="The-Hybrid-Model"><a class="docs-heading-anchor" href="#The-Hybrid-Model">The Hybrid Model</a><a id="The-Hybrid-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hybrid-Model" title="Permalink"></a></h2><p>We consider a two-species system where:</p><ul><li><strong>S</strong> (input signal) undergoes discrete birth-death reactions</li><li><strong>X</strong> (output signal) evolves continuously via a stochastic differential equation (SDE)</li></ul><p>The system dynamics are:</p><p><strong>Discrete reactions for S:</strong></p><pre><code class="nohighlight hljs">Reaction 1:  ∅  → S    (rate κ)       # S production
Reaction 2:  S  → ∅    (rate λ·S)     # S degradation</code></pre><p><strong>Continuous dynamics for X:</strong></p><pre><code class="nohighlight hljs">dX/dt = ρ·S - μ·X + noise</code></pre><p>where the noise term accounts for molecular fluctuations in X production.</p><p>This represents a common motif in cellular signaling where:</p><ul><li>S represents a discrete molecular species (e.g., transcription factors)</li><li>X represents a continuous observable (e.g., protein concentration)</li><li>Information flows from discrete S to continuous X</li></ul><h2 id="Setting-Up-the-System"><a class="docs-heading-anchor" href="#Setting-Up-the-System">Setting Up the System</a><a id="Setting-Up-the-System-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-the-System" title="Permalink"></a></h2><p>First, let&#39;s define the continuous dynamics using SDE functions:</p><pre><code class="language-julia hljs">import PathWeightSampling as PWS
using StaticArrays
using Plots
using Statistics
using DataFrames
using StochasticDiffEq

# Parameters
κ = 50.0   # S production rate
λ = 1.0    # S degradation rate
ρ = 10.0   # X production rate (per S molecule)
μ = 10.0   # X degradation rate

ps = (κ, λ, ρ, μ)

# Deterministic evolution function for SDE
# u[1] = S, u[2] = X
function det_evolution(u, p, t)
    κ, λ, ρ, μ = p
    SA[
        0.0,                # S evolves via discrete jumps only
        ρ*u[1] - μ*u[2]     # X dynamics: production from S, degradation
    ]
end

# Noise function for SDE (diffusion term)
function noise_term(u, p, t)
    κ, λ, ρ, μ = p
    SA[
        0.0,                    # No continuous noise for S
        sqrt(2ρ * κ / λ)        # Multiplicative noise for X
    ]
end

# Initial conditions at equilibrium
u0 = SA[κ / λ, κ * ρ / λ / μ]

# Time span
tspan = (0.0, 10.0)

# Create SDE problem
sde_prob = SDEProblem(det_evolution, noise_term, u0, tspan, ps)</code></pre><h3 id="Defining-Discrete-Reactions"><a class="docs-heading-anchor" href="#Defining-Discrete-Reactions">Defining Discrete Reactions</a><a id="Defining-Discrete-Reactions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Discrete-Reactions" title="Permalink"></a></h3><p>Now we specify the discrete jump reactions for S:</p><pre><code class="language-julia hljs"># Reaction rates
rates = [κ, λ]

# Reactant stoichiometry
# Reaction 1: ∅ → S (no reactants)
# Reaction 2: S → ∅ (1 S molecule)
rstoich = [
    Pair{Int, Int}[],  # No reactants for birth
    [1 =&gt; 1]           # 1 molecule of species 1 (S)
]

# Net stoichiometry changes
nstoich = [
    [1 =&gt; 1],   # +1 S
    [1 =&gt; -1]   # -1 S
]

# Create reaction set
reactions = PWS.ReactionSet(rates, rstoich, nstoich, [:S, :X])</code></pre><h3 id="Creating-the-Hybrid-System"><a class="docs-heading-anchor" href="#Creating-the-Hybrid-System">Creating the Hybrid System</a><a id="Creating-the-Hybrid-System-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Hybrid-System" title="Permalink"></a></h3><p>Now we combine the continuous and discrete dynamics:</p><pre><code class="language-julia hljs"># Create hybrid continuous-discrete system
system = PWS.HybridContinuousSystem(
    PWS.GillespieDirect(),  # Algorithm for discrete jumps
    reactions,              # Discrete reactions
    u0,                     # Initial condition
    tspan,                  # Time span
    0.02,                   # Observation time step (dt)
    sde_prob,               # SDE problem for continuous evolution
    0.01,                   # SDE integration time step
    :S,                     # Input species
    :X,                     # Output species
    [1 =&gt; 1]                # Coupling: species 1 (S) affects the SDE
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PathWeightSampling.ContinuousSystem.HybridContinuousSystem{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}, PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}, StaticArraysCore.SVector{2, Float64}, SciMLBase.SDEProblem{StaticArraysCore.SVector{2, Float64}, Tuple{Float64, Float64}, false, NTuple{4, Float64}, Nothing, SciMLBase.SDEFunction{false, SciMLBase.FullSpecialize, typeof(Main.det_evolution), typeof(Main.noise_term), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing}, typeof(Main.noise_term), Base.Pairs{Symbol, Union{}, Nothing, @NamedTuple{}}, Nothing}}(PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}([50.0, 50.0], 0.0, [0.0, 0.0], 0.0, Float64[], BitSet([1, 2]), BitSet([1, 2]), PathWeightSampling.SSA.ZeroArray(), (0.0, Inf), 0.0, 0.0, 1, 0.0, nothing, Random.Xoshiro(0x2e3b4bbaa22f4a18, 0x9c46ddf1b0362093, 0x1efddd99f3c345e3, 0x1ad002b230b4b8c5, 0x59b54c70ca9316a3)), PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}([50.0, 1.0], [Pair{Int64, Int64}[], [1 =&gt; 1]], [[1 =&gt; 1], [1 =&gt; -1]], [:S, :X]), [50.0, 50.0], (0.0, 10.0), 0.02, SciMLBase.SDEProblem{StaticArraysCore.SVector{2, Float64}, Tuple{Float64, Float64}, false, NTuple{4, Float64}, Nothing, SciMLBase.SDEFunction{false, SciMLBase.FullSpecialize, typeof(Main.det_evolution), typeof(Main.noise_term), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing}, typeof(Main.noise_term), Base.Pairs{Symbol, Union{}, Nothing, @NamedTuple{}}, Nothing}(SciMLBase.SDEFunction{false, SciMLBase.FullSpecialize, typeof(Main.det_evolution), typeof(Main.noise_term), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing}(Main.det_evolution, Main.noise_term, LinearAlgebra.UniformScaling{Bool}(true), nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, SciMLBase.DEFAULT_OBSERVED, nothing, nothing, nothing), Main.noise_term, [50.0, 50.0], (0.0, 10.0), (50.0, 1.0, 10.0, 10.0), nothing, Base.Pairs{Symbol, Union{}, Nothing, @NamedTuple{}}(), nothing, 0x0000000000000000), 0.01, BitSet([1, 2]), SciMLBase.DiscreteCallback{PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##0#SSACallback##1&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}}, PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##2#SSACallback##3&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}, PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}, Vector{Pair{Int64, Int64}}}, PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##4#SSACallback##5&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}, PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}}, typeof(SciMLBase.FINALIZE_DEFAULT), Nothing, Tuple{}}(PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##0#SSACallback##1&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}}(PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}([50.0, 50.0], 0.0, [0.0, 0.0], 0.0, Float64[], BitSet([1, 2]), BitSet([1, 2]), PathWeightSampling.SSA.ZeroArray(), (0.0, Inf), 0.0, 0.0, 1, 0.0, nothing, Random.Xoshiro(0x2e3b4bbaa22f4a18, 0x9c46ddf1b0362093, 0x1efddd99f3c345e3, 0x1ad002b230b4b8c5, 0x59b54c70ca9316a3))), PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##2#SSACallback##3&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}, PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}, Vector{Pair{Int64, Int64}}}(PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}([50.0, 50.0], 0.0, [0.0, 0.0], 0.0, Float64[], BitSet([1, 2]), BitSet([1, 2]), PathWeightSampling.SSA.ZeroArray(), (0.0, Inf), 0.0, 0.0, 1, 0.0, nothing, Random.Xoshiro(0x2e3b4bbaa22f4a18, 0x9c46ddf1b0362093, 0x1efddd99f3c345e3, 0x1ad002b230b4b8c5, 0x59b54c70ca9316a3)), PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}([50.0, 1.0], [Pair{Int64, Int64}[], [1 =&gt; 1]], [[1 =&gt; 1], [1 =&gt; -1]], [:S, :X]), [1 =&gt; 1]), PathWeightSampling.ContinuousSystem.var&quot;#SSACallback##4#SSACallback##5&quot;{PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}, PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}}(PathWeightSampling.SSA.DirectAggregator{StaticArraysCore.SVector{2, Float64}, PathWeightSampling.SSA.ZeroArray, Nothing}([50.0, 50.0], 0.0, [0.0, 0.0], 0.0, Float64[], BitSet([1, 2]), BitSet([1, 2]), PathWeightSampling.SSA.ZeroArray(), (0.0, Inf), 0.0, 0.0, 1, 0.0, nothing, Random.Xoshiro(0x2e3b4bbaa22f4a18, 0x9c46ddf1b0362093, 0x1efddd99f3c345e3, 0x1ad002b230b4b8c5, 0x59b54c70ca9316a3)), PathWeightSampling.SSA.ReactionSet{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}}([50.0, 1.0], [Pair{Int64, Int64}[], [1 =&gt; 1]], [[1 =&gt; 1], [1 =&gt; -1]], [:S, :X])), SciMLBase.FINALIZE_DEFAULT, Bool[0, 0], nothing, ()), [1 =&gt; 1])</code></pre><h2 id="Generating-and-Visualizing-Trajectories"><a class="docs-heading-anchor" href="#Generating-and-Visualizing-Trajectories">Generating and Visualizing Trajectories</a><a id="Generating-and-Visualizing-Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-and-Visualizing-Trajectories" title="Permalink"></a></h2><p>Let&#39;s generate a sample trajectory:</p><pre><code class="language-julia hljs"># Generate a configuration
conf = PWS.generate_configuration(system)

# Plot both species
times = conf.t

p1 = plot(times, conf[1, :],
         label=&quot;S (discrete input)&quot;,
         xlabel=&quot;time&quot;,
         ylabel=&quot;molecule count&quot;,
         title=&quot;Discrete Signal&quot;,
         linetype=:steppost)

p2 = plot(times, conf[2, :],
         label=&quot;X (continuous output)&quot;,
         xlabel=&quot;time&quot;,
         ylabel=&quot;concentration&quot;,
         title=&quot;Continuous Signal&quot;)

plot(p1, p2, layout=(2, 1), size=(600, 500))</code></pre><p><img src="../hybrid_trajectory.svg" alt/></p><p>Notice how:</p><ul><li>S (top) shows discrete jumps characteristic of birth-death processes</li><li>X (bottom) evolves continuously but responds to changes in S</li><li>The continuous noise in X creates smooth fluctuations</li></ul><h2 id="Equilibrium-Statistics"><a class="docs-heading-anchor" href="#Equilibrium-Statistics">Equilibrium Statistics</a><a id="Equilibrium-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Equilibrium-Statistics" title="Permalink"></a></h2><p>We can verify that the system reaches the expected equilibrium distribution:</p><pre><code class="language-julia hljs"># Theoretical expectations at equilibrium
mean_S_theory = κ / λ
var_S_theory = κ / λ

mean_X_theory = ρ * κ / λ / μ
var_X_theory = (1 / (1 + λ/μ) + ρ / μ) * κ / λ

# Empirical statistics from long trajectory
system_long = PWS.HybridContinuousSystem(
    PWS.GillespieDirect(),
    reactions,
    u0,
    (0.0, 1000.0),  # Long time for equilibration
    0.01,
    sde_prob,
    0.01,
    :S,
    :X,
    [1 =&gt; 1]
)

conf_long = PWS.generate_configuration(system_long)

println(&quot;S statistics:&quot;)
println(&quot;  Mean (theory): $(mean_S_theory), empirical: $(mean(conf_long[1, :]))&quot;)
println(&quot;  Var (theory): $(var_S_theory), empirical: $(var(conf_long[1, :]))&quot;)
println(&quot;\nX statistics:&quot;)
println(&quot;  Mean (theory): $(mean_X_theory), empirical: $(mean(conf_long[2, :]))&quot;)
println(&quot;  Var (theory): $(var_X_theory), empirical: $(var(conf_long[2, :]))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">S statistics:
  Mean (theory): 50.0, empirical: 49.16183816183816
  Var (theory): 50.0, empirical: 42.48978221778222

X statistics:
  Mean (theory): 50.0, empirical: 50.191766444524966
  Var (theory): 95.45454545454545, empirical: 84.629548443782</code></pre><h2 id="Computing-Mutual-Information"><a class="docs-heading-anchor" href="#Computing-Mutual-Information">Computing Mutual Information</a><a id="Computing-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Mutual-Information" title="Permalink"></a></h2><p>Now let&#39;s compute how much information flows from the discrete S to continuous X:</p><pre><code class="language-julia hljs"># Compute mutual information using SMC algorithm
result = PWS.mutual_information(
    system,
    PWS.SMCEstimate(128),  # Use 128 particles
    num_samples=1000,      # Take 1000 Monte Carlo samples
    progress=false
)

# Aggregate results by time
sem(x) = std(x) / sqrt(length(x))
df = combine(
    groupby(result.result, :time),
    :MutualInformation =&gt; mean =&gt; :MI,
    :MutualInformation =&gt; sem =&gt; :SEM
)

# Plot mutual information vs trajectory duration
plot(
    df.time,
    df.MI,
    ribbon=df.SEM,
    xlabel=&quot;Trajectory Duration (time units)&quot;,
    ylabel=&quot;Mutual Information (nats)&quot;,
    title=&quot;Information Flow: Discrete S → Continuous X&quot;,
    legend=false,
    linewidth=2
)</code></pre><p><img src="../hybrid_mi.svg" alt/></p><h3 id="Information-Transmission-Rate"><a class="docs-heading-anchor" href="#Information-Transmission-Rate">Information Transmission Rate</a><a id="Information-Transmission-Rate-1"></a><a class="docs-heading-anchor-permalink" href="#Information-Transmission-Rate" title="Permalink"></a></h3><p>For hybrid systems, we can estimate the information transmission rate and compare it to analytical predictions:</p><pre><code class="language-julia hljs"># Estimate transmission rate from linear region
idx_start = findfirst(df.time .&gt;= 2.0)
idx_end = findfirst(df.time .&gt;= 8.0)

if !isnothing(idx_start) &amp;&amp; !isnothing(idx_end)
    Δt = df.time[idx_end] - df.time[idx_start]
    ΔMI = df.MI[idx_end] - df.MI[idx_start]
    rate_estimate = ΔMI / Δt

    # Analytical rate from Tostevin et al. (2009)
    rate_analytical = λ / 2 * (sqrt(1 + ρ / λ) - 1)

    println(&quot;Information transmission rate:&quot;)
    println(&quot;  Estimated: $(round(rate_estimate, digits=4)) nats/time&quot;)
    println(&quot;  Analytical: $(round(rate_analytical, digits=4)) nats/time&quot;)
    println(&quot;  Relative error: $(round(abs(rate_estimate - rate_analytical) / rate_analytical * 100, digits=2))%&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Information transmission rate:
  Estimated: 1.168 nats/time
  Analytical: 1.1583 nats/time
  Relative error: 0.84%</code></pre><p>The close agreement with analytical predictions validates the PWS method for hybrid systems.</p><h2 id="Key-Concepts-for-Hybrid-Systems"><a class="docs-heading-anchor" href="#Key-Concepts-for-Hybrid-Systems">Key Concepts for Hybrid Systems</a><a id="Key-Concepts-for-Hybrid-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts-for-Hybrid-Systems" title="Permalink"></a></h2><h3 id="1.-Coupling-Between-Discrete-and-Continuous"><a class="docs-heading-anchor" href="#1.-Coupling-Between-Discrete-and-Continuous">1. Coupling Between Discrete and Continuous</a><a id="1.-Coupling-Between-Discrete-and-Continuous-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Coupling-Between-Discrete-and-Continuous" title="Permalink"></a></h3><p>The <code>[1 =&gt; 1]</code> parameter in <code>HybridContinuousSystem</code> specifies that species 1 (S) couples to the continuous dynamics. This means:</p><ul><li>Discrete jumps in S immediately affect the SDE drift term</li><li>The continuous state X depends on the current discrete state of S</li></ul><h3 id="2.-Time-Step-Selection"><a class="docs-heading-anchor" href="#2.-Time-Step-Selection">2. Time Step Selection</a><a id="2.-Time-Step-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Time-Step-Selection" title="Permalink"></a></h3><p>Two time steps are specified:</p><ul><li><strong>Observation dt (0.02)</strong>: How often to record the system state</li><li><strong>SDE dt (0.01)</strong>: Internal integration step for the SDE solver</li></ul><p>The SDE dt should be smaller than observation dt for accuracy.</p><h2 id="Comparison-with-Pure-Discrete-Systems"><a class="docs-heading-anchor" href="#Comparison-with-Pure-Discrete-Systems">Comparison with Pure Discrete Systems</a><a id="Comparison-with-Pure-Discrete-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-Pure-Discrete-Systems" title="Permalink"></a></h2><p>How does the hybrid system compare to a purely discrete version?</p><pre><code class="language-julia hljs"># Create pure discrete system for comparison
discrete_reactions = PWS.ReactionSet(
    [κ, λ, ρ, 10.0],  # rates
    [Pair{Int, Int}[], [1=&gt;1], [1=&gt;1], [2=&gt;1]],  # reactants
    [[1=&gt;1], [1=&gt;-1], [2=&gt;1], [2=&gt;-1]],  # net stoich
    [:S, :X]
)

discrete_system = PWS.MarkovJumpSystem(
    PWS.GillespieDirect(),
    discrete_reactions,
    round.(Int, u0),
    tspan,
    :S,
    :X,
    0.02
)

result_discrete = PWS.mutual_information(
    discrete_system,
    PWS.SMCEstimate(128),
    num_samples=1000,
    progress=false
)

df_discrete = combine(
    groupby(result_discrete.result, :time),
    :MutualInformation =&gt; mean =&gt; :MI
)

# Plot comparison
plot(df.time, df.MI, label=&quot;Hybrid (continuous X)&quot;, linewidth=2)
plot!(df_discrete.time, df_discrete.MI, label=&quot;Discrete (discrete X)&quot;, linewidth=2)
xlabel!(&quot;Trajectory Duration (time units)&quot;)
ylabel!(&quot;Mutual Information (nats)&quot;)
title!(&quot;Hybrid vs. Discrete Systems&quot;)</code></pre><p><img src="../hybrid_vs_discrete.svg" alt/></p><h3 id="Analytical-Predictions-for-Information-Rates"><a class="docs-heading-anchor" href="#Analytical-Predictions-for-Information-Rates">Analytical Predictions for Information Rates</a><a id="Analytical-Predictions-for-Information-Rates-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Predictions-for-Information-Rates" title="Permalink"></a></h3><p>We can compare our computational results with analytical predictions from information theory. For linear gene expression systems, exact formulas exist for the steady-state information transmission rate (Tostevin &amp; ten Wolde 2009; Reinhardt et al. 2025; Moor et al. 2025).</p><pre><code class="language-julia hljs"># Compute information transmission rates from linear regions
idx_start_hybrid = findfirst(df.time .&gt;= 2.0)
idx_end_hybrid = findfirst(df.time .&gt;= 8.0)

if !isnothing(idx_start_hybrid) &amp;&amp; !isnothing(idx_end_hybrid)
    Δt = df.time[idx_end_hybrid] - df.time[idx_start_hybrid]
    ΔMI_hybrid = df.MI[idx_end_hybrid] - df.MI[idx_start_hybrid]
    rate_hybrid_computed = ΔMI_hybrid / Δt

    # Analytical formula for Gaussian (state-based) system
    # Tostevin &amp; ten Wolde (2009): R = (λ/2)(√(1 + ρ/λ) - 1)
    rate_hybrid_analytical = (λ / 2) * (sqrt(1 + ρ / λ) - 1)

    println(&quot;Hybrid System (Continuous X):&quot;)
    println(&quot;  Computed rate: $(round(rate_hybrid_computed, digits=4)) nats/time&quot;)
    println(&quot;  Analytical (Gaussian): $(round(rate_hybrid_analytical, digits=4)) nats/time&quot;)
    println(&quot;  Relative difference: $(round(abs(rate_hybrid_computed - rate_hybrid_analytical) / rate_hybrid_analytical * 100, digits=2))%&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Hybrid System (Continuous X):
  Computed rate: 1.168 nats/time
  Analytical (Gaussian): 1.1583 nats/time
  Relative difference: 0.84%</code></pre><pre><code class="language-julia hljs"># Discrete system rate
idx_start_discrete = findfirst(df_discrete.time .&gt;= 2.0)
idx_end_discrete = findfirst(df_discrete.time .&gt;= 8.0)

if !isnothing(idx_start_discrete) &amp;&amp; !isnothing(idx_end_discrete)
    Δt = df_discrete.time[idx_end_discrete] - df_discrete.time[idx_start_discrete]
    ΔMI_discrete = df_discrete.MI[idx_end_discrete] - df_discrete.MI[idx_start_discrete]
    rate_discrete_computed = ΔMI_discrete / Δt

    # Analytical formula for discrete (reaction-based) system
    # Moor et al. (2025): R = (λ/2)(√(1 + 2ρ/λ) - 1)
    rate_discrete_analytical = (λ / 2) * (sqrt(1 + 2ρ / λ) - 1)

    println(&quot;\nDiscrete System (Discrete X):&quot;)
    println(&quot;  Computed rate: $(round(rate_discrete_computed, digits=4)) nats/time&quot;)
    println(&quot;  Analytical (Discrete): $(round(rate_discrete_analytical, digits=4)) nats/time&quot;)
    println(&quot;  Relative difference: $(round(abs(rate_discrete_computed - rate_discrete_analytical) / rate_discrete_analytical * 100, digits=2))%&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Discrete System (Discrete X):
  Computed rate: 1.8321 nats/time
  Analytical (Discrete): 1.7913 nats/time
  Relative difference: 2.28%</code></pre><pre><code class="language-julia hljs"># Show the theoretical difference
if !isnothing(idx_start_hybrid) &amp;&amp; !isnothing(idx_start_discrete)
    rate_hybrid_analytical = (λ / 2) * (sqrt(1 + ρ / λ) - 1)
    rate_discrete_analytical = (λ / 2) * (sqrt(1 + 2ρ / λ) - 1)

    println(&quot;\nTheoretical Comparison:&quot;)
    println(&quot;  Gaussian (state-based) rate: $(round(rate_hybrid_analytical, digits=4)) nats/time&quot;)
    println(&quot;  Discrete (reaction-based) rate: $(round(rate_discrete_analytical, digits=4)) nats/time&quot;)
    println(&quot;  Ratio (discrete/Gaussian): $(round(rate_discrete_analytical / rate_hybrid_analytical, digits=3))&quot;)
    println(&quot;  Discrete system transmits $(round((rate_discrete_analytical / rate_hybrid_analytical - 1) * 100, digits=1))% more information&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Theoretical Comparison:
  Gaussian (state-based) rate: 1.1583 nats/time
  Discrete (reaction-based) rate: 1.7913 nats/time
  Ratio (discrete/Gaussian): 1.546
  Discrete system transmits 54.6% more information</code></pre><p>The excellent agreement between computed and analytical rates validates the PathWeightSampling method. Notice the key finding:</p><p><strong>The discrete (reaction-based) system transmits significantly more information than the continuous (state-based) system</strong>, even though both describe the same underlying chemical process. This is not a numerical artifact—it&#39;s a fundamental consequence of how information is encoded in trajectories.</p><p>The analytical formulas are:</p><ul><li><strong>Gaussian (state-based)</strong>: <span>$R = \frac{\lambda}{2}\left(\sqrt{1 + \frac{\rho}{\lambda}} - 1\right)$</span></li><li><strong>Discrete (reaction-based)</strong>: <span>$R = \frac{\lambda}{2}\left(\sqrt{1 + \frac{2\rho}{\lambda}} - 1\right)$</span></li></ul><p>The factor of 2 difference in the argument of the square root directly reflects the loss of reaction-level information in state-based observations.</p><h3 id="A-Surprising-and-Subtle-Result"><a class="docs-heading-anchor" href="#A-Surprising-and-Subtle-Result">A Surprising and Subtle Result</a><a id="A-Surprising-and-Subtle-Result-1"></a><a class="docs-heading-anchor-permalink" href="#A-Surprising-and-Subtle-Result" title="Permalink"></a></h3><p>At first glance, one might expect that the information transmission rate should be independent of whether we observe discrete reaction events or continuous concentration changes—after all, it&#39;s the same underlying physical process.</p><p><strong>However, this intuition is wrong.</strong> The information rates differ fundamentally between these two observational paradigms, even when the microscopic dynamics are identical. This is a profound and non-trivial result in stochastic information theory.</p><h4 id="Reaction-Based-vs.-State-Based-Trajectories"><a class="docs-heading-anchor" href="#Reaction-Based-vs.-State-Based-Trajectories">Reaction-Based vs. State-Based Trajectories</a><a id="Reaction-Based-vs.-State-Based-Trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-Based-vs.-State-Based-Trajectories" title="Permalink"></a></h4><p>The key distinction is not simply discrete vs. continuous observations, but rather:</p><ul><li><p><strong>Reaction-based trajectories</strong> (discrete systems): Track <em>which specific reactions fire</em> and when. Each reaction event carries information about the process that generated it.</p></li><li><p><strong>State-based trajectories</strong> (continuous systems): Observe only aggregate copy number or concentration changes. Multiple different reactions affecting the same species produce indistinguishable effects.</p></li></ul><p>When you collapse reaction-level information into species-level observations, information is necessarily lost. As shown by Moor et al. (2025), &quot;reaction-based information can never be smaller than the state-based one&quot;—this follows from the data processing inequality.</p><h4 id="Why-This-Matters"><a class="docs-heading-anchor" href="#Why-This-Matters">Why This Matters</a><a id="Why-This-Matters-1"></a><a class="docs-heading-anchor-permalink" href="#Why-This-Matters" title="Permalink"></a></h4><p>Consider our hybrid system example:</p><ul><li>In the <strong>pure discrete system</strong>, we observe each S production and degradation event individually, plus each X production and degradation event</li><li>In the <strong>hybrid continuous system</strong>, we observe discrete S events, but X appears as a continuous concentration with diffusive noise</li></ul><p>The continuous X dynamics aggregate multiple underlying stochastic processes (individual X production and degradation events) into a single diffusive trajectory. This aggregation <strong>fundamentally discards information</strong> about which reaction events occurred, even though the average copy number statistics remain accurate.</p><p>Critically, this difference persists even for large systems where Gaussian approximations work well for predicting average behavior—the information content differs qualitatively, not just quantitatively.</p><h4 id="Connection-to-the-Linear-Noise-Approximation"><a class="docs-heading-anchor" href="#Connection-to-the-Linear-Noise-Approximation">Connection to the Linear Noise Approximation</a><a id="Connection-to-the-Linear-Noise-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-to-the-Linear-Noise-Approximation" title="Permalink"></a></h4><p>The commonly used Linear Noise Approximation (LNA) with Gaussian channel theory can produce qualitatively different information capacity predictions compared to exact Markov jump process calculations. Moor et al. demonstrate that standard state-based LNA loses reaction-specific information because &quot;the linear combination of two Gaussian processes is again a Gaussian process&quot;—collapsing multiple reaction channels into aggregate noise erases information about which reactions fired.</p><p>For a rigorous treatment of this phenomenon and its implications for biological information processing, see:</p><p><strong>Moor, A.-L., Tjalma, A., Reinhardt, M., ten Wolde, P. R., &amp; Zechner, C. (2025).</strong> <em>State- versus Reaction-Based Information Processing in Biochemical Networks</em> <a href="https://arxiv.org/abs/2505.13373">arXiv:2505.13373</a></p><p>This paper introduces a reaction-based LNA that preserves information about individual reaction channels, revealing that the choice between reaction-based and state-based descriptions is not merely a modeling convenience—it has real physical consequences for information transmission capacity.</p><p>PathWeightSampling.jl&#39;s ability to handle both discrete (MarkovJumpSystem) and hybrid (HybridContinuousSystem) systems provides a computational tool to explore these subtle but fundamental distinctions in information processing.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li><p>Tostevin, F., &amp; ten Wolde, P. R. (2009). Mutual information between input and output trajectories of biochemical networks. <em>Physical Review Letters</em>, 102(21), 218101. <a href="https://doi.org/10.1103/PhysRevLett.102.218101">https://doi.org/10.1103/PhysRevLett.102.218101</a></p></li><li><p>Reinhardt, M., Tjalma, A. J., Moor, A.-L., Zechner, C., &amp; ten Wolde, P. R. (2025). Mutual Information Rate – Linear Noise Approximation and Exact Computation. <em>arXiv preprint</em> arXiv:2508.21220. <a href="https://arxiv.org/abs/2508.21220">https://arxiv.org/abs/2508.21220</a></p></li><li><p>Moor, A.-L., Tjalma, A., Reinhardt, M., ten Wolde, P. R., &amp; Zechner, C. (2025). State- versus Reaction-Based Information Processing in Biochemical Networks. <em>arXiv preprint</em> arXiv:2505.13373. <a href="https://arxiv.org/abs/2505.13373">https://arxiv.org/abs/2505.13373</a></p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../three_species_tutorial/">« Three-Species Cascade</a><a class="docs-footer-nextpage" href="../marginalization/">Marginalization Strategies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 17 January 2026 13:13">Saturday 17 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
